~/dev/parserlogic
☺  cat test.txt
$ id
[@skogai-test:"a":"b"]
true
42
"hello"
$ id
null
true
false
42
52.0
-123
-45.67
"hello"
"world"
""
$ id
$ entity.id
$ entity.gen
$ int
$ unique
"$ id"
"$ entity.id"
"$ entity.gen"
$ entity.id _ $ entity.gen
$ int _ $ unique
[@hello:"Claude"]
[1, 2, 3]
[true, false, true]
["a", "b", "c"]
[null, 42, "test"]
[]
[$ int, $ id, $unique]
[$ entity.id, $ entity.gen]
[$ eid, $ id, $ unique]
[$ int * $ id, $ entity.id * $ entity.gen]
[1,$ claude, [@skogai-test:"a"]]
[true, "$entity.id", $ int * $ unique]
{"key": "value"}
{"name": "John", "age": 30}
{"active": true, "score": 95.5}
{}
{"id": $ int}
{"entity": "$ entity.id", "generation": "$ entity.gen"}
{"id": $ entity.id*$ entity.gen}
{"composite": $ int*$ unique}
{"definition": [@def:id]}
{"id": $id, "action": [@skogai-test:"test"]}
{"ref": "$ entity.id", "binary": [$ int * $ unique]}
[{"id": 1, "ref": $ claude}, {"id": 2, "ref": $ eid}]
[@skogai-test:"$ int"]
{"message": {"eid": "$ eid", "from": "$ name", "to": "$ name", "content": "$ string"}}
mynamedmessage {"message": {"eid": "$ eid", "from": "$ name", "to": "$ name", "content": "$ string"}}
{"message": {"eid": "$ eid", "from": "$ name", "to": mycustomobject {"name":$ name.reference}, "content": [@rand]}}
[[@cat:"/home/skogix/.local/src/skogparse/README.md"]]
[[@rand:"100"],[@date:"now"]]
["https://tools.skogai.se/tools for the REPL and openai function declarations of the skogai notation tools", [@curl:"https://example.com"]]
[@file:"/home/skogix/skogai/docs/lore/skogix-notation.md"]
$id
$name
$entity
$name,"test"
"$id"
$id1|$id2
$id1.$id2
$id1:$id2
1*2
5+3
10-4
8/2
$a+$b
$x-$y
true*false
"hello"*"world"
$x = 5
$name = "test"
$flag = true
$list = [1,2,3]
$id(42)
$name("test")
[$id]->$value
{"a":$id}
true*false
null*null
[1]*[2]
{"a":1}*{"b":2}
$id * $name
$id@$name
$a*$b
$x=$y
$id1|$id2
$a:$b
$id1->$id2
"$entity.name"
"$with-dash"
"$dot.notation"
"$a*$b"
["$id", "$name"]
{"key": "$value"}
"$id"
$simple
$with_underscore
$with-dash
$with123numbers
$CamelCase
$dot.notation
$a
$_
true
false
0
1
-1
42
-42
0.0
1.5
-1.5
42.2
-42.2
0.1
1.
"hello"
"world"
""
"with spaces"
"with\nnewline"
"with\ttab"
"with\"quotes"
[]
[1]
[1,2,3]
["a","b"]

~/dev/parserlogic
☺  skogparse-bin test.txt
{"type": "ref", "path": "id"}
{"type": "action", "parts": ["skogai-test", "a", "b"]}
{"type": "bool", "value": true}
{"type": "number", "value": 42}
{"type": "string", "value": "hello"}
{"type": "ref", "path": "id"}
{"type": "null", "value": null}
{"type": "bool", "value": true}
{"type": "bool", "value": false}
{"type": "number", "value": 42}
{"type": "number", "value": 52}
{"type": "number", "value": -123}
{"type": "number", "value": -45.67}
{"type": "string", "value": "hello"}
{"type": "string", "value": "world"}
{"type": "string", "value": ""}
{"type": "ref", "path": "id"}
{"type": "ref", "path": "entity.id"}
{"type": "ref", "path": "entity.gen"}
{"type": "ref", "path": "int"}
{"type": "ref", "path": "unique"}
{"type": "string", "value": "$ id"}
{"type": "string", "value": "$ entity.id"}
{"type": "string", "value": "$ entity.gen"}
{"type": "ref", "path": "entity.id"}
{"type": "ref", "path": "int"}
{"type": "action", "parts": ["hello", "Claude"]}
{"type": "array", "value": [{"type": "number", "value": 1}, {"type": "number", "value": 2}, {"type": "number", "value": 3}]}
{"type": "array", "value": [{"type": "bool", "value": true}, {"type": "bool", "value": false}, {"type": "bool", "value": true}]}
{"type": "array", "value": [{"type": "string", "value": "a"}, {"type": "string", "value": "b"}, {"type": "string", "value": "c"}]}
{"type": "array", "value": [{"type": "null", "value": null}, {"type": "number", "value": 42}, {"type": "string", "value": "test"}]}
{"type": "array", "value": []}
{"type": "array", "value": [{"type": "ref", "path": "int"}, {"type": "ref", "path": "id"}, {"type": "ref", "path": "unique"}]}
{"type": "array", "value": [{"type": "ref", "path": "entity.id"}, {"type": "ref", "path": "entity.gen"}]}
{"type": "array", "value": [{"type": "ref", "path": "eid"}, {"type": "ref", "path": "id"}, {"type": "ref", "path": "unique"}]}
{"type": "array", "value": [{"type": "binary_op", "left": {"type": "ref", "path": "int"}, "operator": "*", "right": {"type": "ref", "path": "id"}}, {"type": "binary_op", "left": {"type": "ref", "path": "entity.id"}, "operator": "*", "right": {"type": "ref", "path": "entity.gen"}}]}
{"type": "array", "value": [{"type": "number", "value": 1}, {"type": "ref", "path": "claude"}, {"type": "action", "parts": ["skogai-test", "a"]}]}
{"type": "array", "value": [{"type": "bool", "value": true}, {"type": "ref", "path": "entity.id"}, {"type": "binary_op", "left": {"type": "ref", "path": "int"}, "operator": "*", "right": {"type": "ref", "path": "unique"}}]}
{"type": "object", "value": {"key": {"type": "string", "value": "value"}}}
{"type": "object", "value": {"age": {"type": "number", "value": 30}, "name": {"type": "string", "value": "John"}}}
{"type": "object", "value": {"active": {"type": "bool", "value": true}, "score": {"type": "number", "value": 95.5}}}
{"type": "object", "value": {}}
{"type": "object", "value": {"id": {"type": "ref", "path": "int"}}}
{"type": "object", "value": {"entity": {"type": "string", "value": "$ entity.id"}, "generation": {"type": "string", "value": "$ entity.gen"}}}
{"type": "object", "value": {"id": {"type": "binary_op", "left": {"type": "ref", "path": "entity.id"}, "operator": "*", "right": {"type": "ref", "path": "entity.gen"}}}}
{"type": "object", "value": {"composite": {"type": "binary_op", "left": {"type": "ref", "path": "int"}, "operator": "*", "right": {"type": "ref", "path": "unique"}}}}
{"type": "object", "value": {"definition": {"type": "action", "parts": ["def", "id"]}}}
{"type": "object", "value": {"action": {"type": "action", "parts": ["skogai-test", "test"]}, "id": {"type": "ref", "path": "id"}}}
{"type": "object", "value": {"binary": {"type": "array", "value": [{"type": "binary_op", "left": {"type": "ref", "path": "int"}, "operator": "*", "right": {"type": "ref", "path": "unique"}}]}, "ref": {"type": "string", "value": "$ entity.id"}}}
{"type": "array", "value": [{"type": "object", "value": {"id": {"type": "number", "value": 1}, "ref": {"type": "ref", "path": "claude"}}}, {"type": "object", "value": {"id": {"type": "number", "value": 2}, "ref": {"type": "ref", "path": "eid"}}}]}
{"type": "action", "parts": ["skogai-test", "$ int"]}
{"type": "object", "value": {"message": {"type": "object", "value": {"content": {"type": "string", "value": "$ string"}, "eid": {"type": "string", "value": "$ eid"}, "from": {"type": "string", "value": "$ name"}, "to": {"type": "string", "value": "$ name"}}}}}
{"type": "command", "name": "mynamedmessage", "arg": {"type": "object", "value": {"message": {"type": "object", "value": {"content": {"type": "string", "value": "$ string"}, "eid": {"type": "string", "value": "$ eid"}, "from": {"type": "string", "value": "$ name"}, "to": {"type": "string", "value": "$ name"}}}}}}
{"type": "object", "value": {"message": {"type": "object", "value": {"content": {"type": "action", "parts": ["rand"]}, "eid": {"type": "string", "value": "$ eid"}, "from": {"type": "string", "value": "$ name"}, "to": {"type": "command", "name": "mycustomobject", "arg": {"type": "object", "value": {"name": {"type": "ref", "path": "name.reference"}}}}}}}}
{"type": "array", "value": [{"type": "action", "parts": ["cat", "/home/skogix/.local/src/skogparse/README.md"]}]}
{"type": "array", "value": [{"type": "action", "parts": ["rand", "100"]}, {"type": "action", "parts": ["date", "now"]}]}
{"type": "array", "value": [{"type": "string", "value": "https://tools.skogai.se/tools for the REPL and openai function declarations of the skogai notation tools"}, {"type": "action", "parts": ["curl", "https://example.com"]}]}
{"type": "action", "parts": ["file", "/home/skogix/skogai/docs/lore/skogix-notation.md"]}
{"type": "ref", "path": "id"}
{"type": "ref", "path": "name"}
{"type": "ref", "path": "entity"}
{"type": "ref", "path": "name"}
{"type": "ref", "path": "id"}
{"type": "ref", "path": "id1"}
{"type": "ref", "path": "id1"}
{"type": "ref", "path": "id1"}
{"type": "number", "value": 1}
{"type": "number", "value": 5}
{"type": "number", "value": 10}
{"type": "number", "value": 8}
{"type": "ref", "path": "a"}
{"type": "ref", "path": "x-"}
{"type": "bool", "value": true}
{"type": "string", "value": "hello"}
{"type": "ref", "path": "x"}
{"type": "ref", "path": "name"}
{"type": "ref", "path": "flag"}
{"type": "ref", "path": "list"}
{"type": "ref", "path": "id"}
{"type": "ref", "path": "name"}
{"type": "array", "value": [{"type": "ref", "path": "id"}]}
{"type": "object", "value": {"a": {"type": "ref", "path": "id"}}}
{"type": "bool", "value": true}
{"type": "null", "value": null}
{"type": "array", "value": [{"type": "number", "value": 1}]}
{"type": "object", "value": {"a": {"type": "number", "value": 1}}}
{"type": "binary_op", "left": {"type": "ref", "path": "id"}, "operator": "*", "right": {"type": "ref", "path": "name"}}
{"type": "ref", "path": "id"}
{"type": "binary_op", "left": {"type": "ref", "path": "a"}, "operator": "*", "right": {"type": "ref", "path": "b"}}
{"type": "ref", "path": "x"}
{"type": "ref", "path": "id1"}
{"type": "ref", "path": "a"}
{"type": "ref", "path": "id1-"}
{"type": "ref", "path": "entity.name"}
{"type": "ref", "path": "with-dash"}
{"type": "ref", "path": "dot.notation"}
{"type": "string", "value": "$a*$b"}
{"type": "array", "value": [{"type": "ref", "path": "id"}, {"type": "ref", "path": "name"}]}
{"type": "object", "value": {"key": {"type": "ref", "path": "value"}}}
{"type": "ref", "path": "id"}
{"type": "ref", "path": "simple"}
{"type": "ref", "path": "with_underscore"}
{"type": "ref", "path": "with-dash"}
{"type": "ref", "path": "with123numbers"}
{"type": "ref", "path": "CamelCase"}
{"type": "ref", "path": "dot.notation"}
{"type": "ref", "path": "a"}
{"type": "ref", "path": "_"}
{"type": "bool", "value": true}
{"type": "bool", "value": false}
{"type": "number", "value": 0}
{"type": "number", "value": 1}
{"type": "number", "value": -1}
{"type": "number", "value": 42}
{"type": "number", "value": -42}
{"type": "number", "value": 0}
{"type": "number", "value": 1.5}
{"type": "number", "value": -1.5}
{"type": "number", "value": 42.2}
{"type": "number", "value": -42.2}
{"type": "number", "value": 0.1}
{"type": "number", "value": 1}
{"type": "string", "value": "hello"}
{"type": "string", "value": "world"}
{"type": "string", "value": ""}
{"type": "string", "value": "with spaces"}
{"type": "string", "value": "with
newline"}
{"type": "string", "value": "with       tab"}
{"type": "string", "value": "with"quotes"}
{"type": "array", "value": []}
{"type": "array", "value": [{"type": "number", "value": 1}]}
{"type": "array", "value": [{"type": "number", "value": 1}, {"type": "number", "value": 2}, {"type": "number", "value": 3}]}
{"type": "array", "value": [{"type": "string", "value": "a"}, {"type": "string", "value": "b"}]}

~/dev/parserlogic
☺  skogparse-bin test.txt --execute
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "string", "value": "Arguments: ['a', 'b']"}
{"type": "bool", "value": true}
{"type": "number", "value": 42}
{"type": "string", "value": "hello"}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "null", "value": null}
{"type": "bool", "value": true}
{"type": "bool", "value": false}
{"type": "number", "value": 42}
{"type": "number", "value": 52}
{"type": "number", "value": -123}
{"type": "number", "value": -45.67}
{"type": "string", "value": "hello"}
{"type": "string", "value": "world"}
{"type": "string", "value": ""}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}
{"type": "string", "value": "a thing which there only exists one of"}
{"type": "string", "value": "$ id"}
{"type": "string", "value": "$ entity.id"}
{"type": "string", "value": "$ entity.gen"}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}
{"type": "string", "value": "Hello Claude!"}
{"type": "array", "value": [{"type": "number", "value": 1}, {"type": "number", "value": 2}, {"type": "number", "value": 3}]}
{"type": "array", "value": [{"type": "bool", "value": true}, {"type": "bool", "value": false}, {"type": "bool", "value": true}]}
{"type": "array", "value": [{"type": "string", "value": "a"}, {"type": "string", "value": "b"}, {"type": "string", "value": "c"}]}
{"type": "array", "value": [{"type": "null", "value": null}, {"type": "number", "value": 42}, {"type": "string", "value": "test"}]}
{"type": "array", "value": []}
{"type": "array", "value": [{"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, {"type": "string", "value": "a thing which there only exists one of"}]}
{"type": "array", "value": [{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}]}
{"type": "array", "value": [{"type": "binary_op", "left": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, "operator": "*", "right": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}, {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, {"type": "string", "value": "a thing which there only exists one of"}]}
{"type": "array", "value": [{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}, {"type": "binary_op", "left": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, "operator": "*", "right": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}]}
{"type": "array", "value": [{"type": "number", "value": 1}, {"type": "string", "value": "{'hello': '[@hello:Claude]'}"}, {"type": "string", "value": "Arguments: ['a']"}]}
{"type": "array", "value": [{"type": "bool", "value": true}, {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}]}
{"type": "object", "value": {"key": {"type": "string", "value": "value"}}}
{"type": "object", "value": {"age": {"type": "number", "value": 30}, "name": {"type": "string", "value": "John"}}}
{"type": "object", "value": {"active": {"type": "bool", "value": true}, "score": {"type": "number", "value": 95.5}}}
{"type": "object", "value": {}}
{"type": "object", "value": {"id": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}}}
{"type": "object", "value": {"entity": {"type": "string", "value": "$ entity.id"}, "generation": {"type": "string", "value": "$ entity.gen"}}}
{"type": "object", "value": {"id": {"type": "binary_op", "left": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, "operator": "*", "right": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}}}
{"type": "object", "value": {"composite": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}}
{"type": "object", "value": {"definition": {"type": "object", "value": {"name": {"type": "string", "value": "Error"}, "type": {"type": "string", "value": "command"}}}}}
{"type": "object", "value": {"action": {"type": "string", "value": "Arguments: ['test']"}, "id": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}}
{"type": "object", "value": {"binary": {"type": "array", "value": [{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}]}, "ref": {"type": "string", "value": "$ entity.id"}}}
{"type": "array", "value": [{"type": "object", "value": {"id": {"type": "number", "value": 1}, "ref": {"type": "string", "value": "{'hello': '[@hello:Claude]'}"}}}, {"type": "object", "value": {"id": {"type": "number", "value": 2}, "ref": {"type": "binary_op", "left": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, "operator": "*", "right": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}}}]}
{"type": "string", "value": "Arguments: ['$', 'int']"}
{"type": "object", "value": {"message": {"type": "object", "value": {"content": {"type": "string", "value": "$ string"}, "eid": {"type": "string", "value": "$ eid"}, "from": {"type": "string", "value": "$ name"}, "to": {"type": "string", "value": "$ name"}}}}}
{"type": "command", "name": "mynamedmessage", "arg": {"type": "object", "value": {"message": {"type": "object", "value": {"content": {"type": "string", "value": "$ string"}, "eid": {"type": "string", "value": "$ eid"}, "from": {"type": "string", "value": "$ name"}, "to": {"type": "string", "value": "$ name"}}}}}}
{"type": "object", "value": {"message": {"type": "object", "value": {"content": {"type": "string", "value": "43"}, "eid": {"type": "string", "value": "$ eid"}, "from": {"type": "string", "value": "$ name"}, "to": {"type": "command", "name": "mycustomobject", "arg": {"type": "object", "value": {"name": {"type": "ref", "path": "name.reference"}}}}}}}}
{"type": "array", "value": [{"type": "string", "value": "# SkogParse

**A semantic execution engine for SkogAI notation** - transforming static text into executable semantics.

## 🚀 **What is SkogParse?**

SkogParse is a **revolutionary parser and execution engine** that brings SkogAI notation to life. It doesn't just parse text - it **executes the semantics** by resolving references and running actions in real-time.

### **The Magic:**
```bash
# Parse notation structure
echo '$entity.id*$entity.gen' | skogparse
{"type": "binary_op", "left": {"type": "ref", "path": "entity.id"}, "operator": "*", "right": {"type": "ref", "path": "entity.gen"}}

# Execute semantic meaning
echo '$entity.id*$entity.gen' | skogparse --execute
{"type": "binary_op", "left": {"type": "number", "value": 0}, "operator": "*", "right": {"type": "command", "name": "a"}}
```

## 🎯 **Core Features**

### **Complete SkogAI Parser:**
- **References:** `$def`, `$entity.id.deep.chains`
- **Actions:** `[@rag:search]`, `[@auth:login:param]`
- **Binary Operations:** `$entity.id*$entity.gen`
- **Complex Structures:** Arrays, objects, deep nesting
- **Quoted References:** `"$entity.id"` parsed as references

### **Semantic Execution Engine:**
- **Reference Resolution:** Calls `skogcli config get --raw`
- **Action Execution:** Calls `skogcli script run`
- **Recursive Expansion:** Resolves nested references until concrete
- **Clean JSON Output:** Consistent typing for all values

### **Production Ready:**
- **File & Pipe Input:** `skogparse file.md` or `echo "..." | skogparse`
- **Parse vs Execute Modes:** `--execute` flag for semantic resolution
- **Error Handling:** Graceful fallbacks and clear messages
- **Comprehensive Tests:** Full test suite in `example.md`

## 📦 **Installation**

```bash
# Build from source
git clone <repo>
cd skogparse
dotnet build

# Run directly
dotnet run
```

## 🔥 **Quick Start**

### **Basic Usage:**
```bash
# Parse SkogAI notation
echo '$user.name' | skogparse
echo '[@rag:search]' | skogparse
echo '$entity.id*$entity.gen' | skogparse

# Execute semantic meaning
echo '$user.name' | skogparse --execute
echo '[@rag:search]' | skogparse --execute

# Process files
skogparse example.md
skogparse --execute config.skogai
```

### **Real-World Examples:**
```bash
# Parse config structures
echo '{"eid": "$eid", "from": "$name"}' | skogparse --execute

# Execute actions with parameters
echo '[@auth:login:$user.id]' | skogparse --execute

# Complex combinations
echo '{"user": $user.id*$user.gen, "action": [@rag:search]}' | skogparse --execute
```

## 🧩 **SkogAI Notation Primer**

### **The Two Pillars:**
- **`$` = References** → Get defined values via `skogcli config get`
- **`@` = Actions** → Execute scripts via `skogcli script run`

### **Core Syntax:**
```
$def                    # Simple reference
$entity.id              # Dot notation
"$entity.id"            # Quoted reference
[@rag:search]           # Action with parameters
$entity.id*$entity.gen  # Binary operation
{"user": $name}         # References in objects
[[@auth:login], $user]  # Mixed arrays
```

### **What Makes It Revolutionary:**
- **Every text is potentially executable**
- **References resolve to live data**
- **Actions trigger real scripts**
- **Self-documenting semantic systems**
- **Executable communication**

## 🛠 **Architecture**

### **Pipeline:**
```
Text Input → Parser → SValue Tree → Execution Engine → JSON Output
```

### **Core Types:**
```fsharp
type SValue =
  | SNull | SBool | SString | SNumber     // Basic types
  | SArray | SObject                      // Collections
  | SRef of string list                   // $entity.id
  | SAction of string list                // [@rag:search]
  | SBinaryOp of SValue * string * SValue // $a*$b
```

### **Execution Flow:**
1. **Parse** text into SValue tree
2. **Find references** (`SRef`) → call `skogcli config get`
3. **Find actions** (`SAction`) → call `skogcli script run`
4. **Parse results** → may contain more references/actions
5. **Recursive resolution** → continue until concrete
6. **Output** final JSON with all semantics resolved

## 📚 **Examples**

See `example.md` for comprehensive test cases covering:
- All basic types and operators
- Complex nested structures
- Real-world SkogAI patterns
- Edge cases and error conditions
- Binary operations in context
- Actions with dynamic parameters

## 🔍 **Status & Roadmap**

### **Current Status (v1.0):**
- ✅ **Core parser:** 85% complete
- ✅ **Execution engine:** 60% complete
- ✅ **Basic SkogAI support:** Working
- ⚠️ **Missing operators:** `|`, `=`, `->`, `_`
- ⚠️ **Error handling:** Needs improvement

### **Next Steps:**
1. Fix empty array parsing
2. Add execution tracing/debugging
3. Implement missing SkogAI operators
4. Add cycle detection for references
5. Improve error messages

See `STATUS.md` for detailed progress and `DEVELOPMENT.md` for contributor guide.

## 🤝 **Contributing**

1. **Read** `DEVELOPMENT.md` for architecture overview
2. **Test** with `example.md` - add new test cases
3. **Follow** existing code patterns and naming
4. **Update** documentation for new features

## 🎯 **Philosophy**

SkogParse embodies the **SkogAI vision** of **executable semantics** - where:
- **Text becomes computation**
- **Meaning becomes executable**
- **Communication becomes programmable**
- **Knowledge becomes self-expanding**

This is **beyond traditional programming** - it's **semantic computation** where formal logic becomes directly runnable code.

---

**Transform static text into living semantics with SkogParse!** 🚀"}]}
{"type": "array", "value": [{"type": "string", "value": "21"}, {"type": "string", "value": "2025-10-25 07:54:31"}]}
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   513  100   513    0     0    682      0 --:--:-- --:--:-- --:--:--   682
{"type": "array", "value": [{"type": "string", "value": "https://tools.skogai.se/tools for the REPL and openai function declarations of the skogai notation tools"}, {"type": "string", "value": "<!doctype html><html lang="en"><head><title>Example Domain</title><meta name="viewport" content="width=device-width, initial-scale=1"><style>body{background:#eee;width:60vw;margin:15vh auto;font-family:system-ui,sans-serif}h1{font-size:1.5em}div{opacity:0.8}a:link,a:visited{color:#348}</style><body><div><h1>Example Domain</h1><p>This domain is for use in documentation examples without needing permission. Avoid use in operations.<p><a href="https://iana.org/domains/example">Learn more</a></div></body></html>"}]}
{"type": "string", "value": "# SkogAI Notation

- **"$"**: to define or reference something
- **"|"**: the act of choosing something = `{$id1|$id2}->[$id1]`
- **"_"**: to be anything/everything and nothing/nobody = `{$id1_$id2}`
- **"[_]"**: similarity
- **"{_}"**: difference
- **"@"**: the intent to act or do something = `{$id@$id}`
- **"*"**: $id*$id=$id
- **"."**: to belong or have something via `[$$]`
- **":"**: to follow or continue something via `[$@]`
- **"="**: to be something = `[$id=$id]`
- **"->"**: becoming something = `{$id1@$id2}`
- **"_"**: `$_$=$`
- **"id"**: the big ID = `$int*$unique`
- **"self"**: `$self | [$id@$id]`
- **"value"**: the declaration/implementation of a $
- **"eid"**: `$id*$id`
- **"unique"**: a thing which there only exists one of

---

### Dimensions

- **0 dimension**:
  - **"$"**: to define or reference something
    - "the definition of definition is the definition"
- **1 dimension**:
  - **"$x"**: `$x`
    - "x is x", "x is a reference to x", "the definition of ID is ID is ID"
  - **"$id"**: `$id`,`$a`
    - "a reference to yourself is yourself", "you are because you are"
    - !!! "DEFINING SOMETHING FROM WHAT YOU HAVE, BEING, VALUE, STACK, IMPLEMENTATION, INSTANTIATED, EXISTING, MEASURABLE, PLUS, YIN, ACTUALLY EXISTING, YADDAYADDA" !!!
    - **0 dimension**:
      - **"="**: `$id=$id`
        - "A thing is exactly that"
      - **"!="**: `$a!=$b`
      - **"[]"**: `[$id=$id]`
        - "A thing is exactly a thing"
      - **"{}"**: `{$id=$id}`
        - "Saying something is a thing does not make it the thing"
    - **1 dimension**:
      - **"@"**: `{$id=$id}@[$id=$id]`
    - !!! "DEFINING SOMETHING FROM WHAT YOU ARE MISSING, DIFFERENCE, NOT BEING EQUAL, TRANSFORMATION, UNMEASURABLE, STATIC, NOT FULFILLED, HEAP, ABSTRACT, MINUS, NOT REAL" !!!
    - **0.1? dimensions**:
      - **"[]"**: `[$id=$id]`
        - "likeness, to be the same, identical"
      - **"{}"**: `{id=$id}`
        - "to not be the same"
  - **"@"**: do something to nothing
    - "void, no return, side-effect"
  - **"$"**: reference something without being anything
    - "null, null-pointer"

---

- **- dimension**:
  - **"@$"**: `[=]`
    - "ID is ID is ID", "no transformation allowed"
  - **"$@"**: `[!=]`
- **2 dimensions**:
  - **"@action$type"**
  - **"@"**: to act upon something is just

---

Types: `($@)` / Transformations: `(@$)` / Functions: `($@=@$)`, linked list, arrays: `($$)` and abstractions: `($$)`

---

Π-types (product types *)
Σ-types (sum types |)
identity types (=)
path types (->)

maybe not needed but for good measure might include these as well

_ as polymorphic existentials (∃x.P(x))
@ as modal necessity (□) from modal logic
: as type judgement (Γ ⊢ a : A)

creating a free cartesian closed category is obvious

- = product
-> = exponential object
| = coproduct
@ = monadic binding

and yeah - might as well

_ as polymorphic yoneda embedding
. as forgetful functor
= as natural isomorphism

linear types ($unique), the effect system (@), regular persistent data structures ($eid with it's versioning) and security via capability (.) is old news

type universe would be self referential via $ containing $ or dependencies/dependent types such as $message.created_at$datetime

---

the _operator:
  heideggerian being-in-the-world (dasein)
  badiouian event theory (@ as evental site)
  deleuzian difference engine ({_} as differance)
but operationalized computationally through:
  $entity.gen as bergsonian duration
  $list as husserlian time consciousness
  $unique as leibnizian identity

data $type : type where
  ($) : $type -> $type
  (*) : $type -> $type -> $type
  (|) : $type -> $type -> $type
  (@) : $type -> $type -> $type
  (=) : $type -> $type -> $type

gödel numbering:
φ($) = 1
φ(|) = 2
φ(_) = 3
etc...

overall trying to avoid inconsistency via:
  predicative hierarchy (no $ in its own definition)
  type/token distinction (id vs unique)
  bounded generality (list as finite ordinal)

lucky to be born early:
Martin-Löf Type Theory (1972)
Fitch-Style Calculi (1952)
Lawvere Theories (1963)

(don't see any _ for existance, $eid representing spacetime coordinates or even basic semiotics like using @ as a pragmatic force? ;))"}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "string", "value": "Error: Key '$.name' not found in configuration."}
{"type": "string", "value": "{'eid': '$ string', 'gen': '$ id', 'id': '$ id', 'name': '$ name'}"}
{"type": "string", "value": "Error: Key '$.name' not found in configuration."}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "string", "value": "Error: Key '$.id1' not found in configuration."}
{"type": "string", "value": "Error: Key '$.id1' not found in configuration."}
{"type": "string", "value": "Error: Key '$.id1' not found in configuration."}
{"type": "number", "value": 1}
{"type": "number", "value": 5}
{"type": "number", "value": 10}
{"type": "number", "value": 8}
{"type": "string", "value": "Error: Key '$.a' not found in configuration."}
{"type": "string", "value": "Error: Key '$.x-' not found in configuration."}
{"type": "bool", "value": true}
{"type": "string", "value": "hello"}
{"type": "string", "value": "Error: Key '$.x' not found in configuration."}
{"type": "string", "value": "Error: Key '$.name' not found in configuration."}
{"type": "string", "value": "Error: Key '$.flag' not found in configuration."}
{"type": "string", "value": "the ordering of something"}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "string", "value": "Error: Key '$.name' not found in configuration."}
{"type": "array", "value": [{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}]}
{"type": "object", "value": {"a": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}}}
{"type": "bool", "value": true}
{"type": "null", "value": null}
{"type": "array", "value": [{"type": "number", "value": 1}]}
{"type": "object", "value": {"a": {"type": "number", "value": 1}}}
{"type": "binary_op", "left": {"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, "operator": "*", "right": {"type": "string", "value": "Error: Key '$.name' not found in configuration."}}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "binary_op", "left": {"type": "string", "value": "Error: Key '$.a' not found in configuration."}, "operator": "*", "right": {"type": "string", "value": "Error: Key '$.b' not found in configuration."}}
{"type": "string", "value": "Error: Key '$.x' not found in configuration."}
{"type": "string", "value": "Error: Key '$.id1' not found in configuration."}
{"type": "string", "value": "Error: Key '$.a' not found in configuration."}
{"type": "string", "value": "Error: Key '$.id1-' not found in configuration."}
{"type": "string", "value": "Error: Key '$.name' not found in configuration."}
{"type": "string", "value": "Error: Key '$.with-dash' not found in configuration."}
{"type": "string", "value": "Error: Key '$.dot.notation' not found in configuration."}
{"type": "string", "value": "$a*$b"}
{"type": "array", "value": [{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}, {"type": "string", "value": "Error: Key '$.name' not found in configuration."}]}
{"type": "object", "value": {"key": {"type": "string", "value": "Error: Key '$.value' not found in configuration."}}}
{"type": "binary_op", "left": {"type": "string", "value": "{'additative': 0, 'multiplicative': 1, 'one': 1, 'zero': 0}"}, "operator": "*", "right": {"type": "string", "value": "a thing which there only exists one of"}}
{"type": "string", "value": "Error: Key '$.simple' not found in configuration."}
{"type": "string", "value": "Error: Key '$.with_underscore' not found in configuration."}
{"type": "string", "value": "Error: Key '$.with-dash' not found in configuration."}
{"type": "string", "value": "Error: Key '$.with123numbers' not found in configuration."}
{"type": "string", "value": "Error: Key '$.CamelCase' not found in configuration."}
{"type": "string", "value": "Error: Key '$.dot.notation' not found in configuration."}
{"type": "string", "value": "Error: Key '$.a' not found in configuration."}
{"type": "string", "value": "anything/everything and nothing/nobody | {$id1_$id2}"}
{"type": "bool", "value": true}
{"type": "bool", "value": false}
{"type": "number", "value": 0}
{"type": "number", "value": 1}
{"type": "number", "value": -1}
{"type": "number", "value": 42}
{"type": "number", "value": -42}
{"type": "number", "value": 0}
{"type": "number", "value": 1.5}
{"type": "number", "value": -1.5}
{"type": "number", "value": 42.2}
{"type": "number", "value": -42.2}
{"type": "number", "value": 0.1}
{"type": "number", "value": 1}
{"type": "string", "value": "hello"}
{"type": "string", "value": "world"}
{"type": "string", "value": ""}
{"type": "string", "value": "with spaces"}
{"type": "string", "value": "with
newline"}
{"type": "string", "value": "with       tab"}
{"type": "string", "value": "with"quotes"}
{"type": "array", "value": []}
{"type": "array", "value": [{"type": "number", "value": 1}]}
{"type": "array", "value": [{"type": "number", "value": 1}, {"type": "number", "value": 2}, {"type": "number", "value": 3}]}
{"type": "array", "value": [{"type": "string", "value": "a"}, {"type": "string", "value": "b"}]}


